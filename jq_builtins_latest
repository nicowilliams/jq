def break: error("break");
def map(f): [.[] | f];
def select(f): if f then . else empty end;
def sort_by(f): _sort_by_impl(map([f]));
def group_by(f): _group_by_impl(map([f]));
def unique: group_by(.) | map(.[0]);
def unique_by(f): group_by(f) | map(.[0]);
def max_by(f): _max_by_impl(map([f]));
def min_by(f): _min_by_impl(map([f]));
def add: reduce .[] as $x (null; . + $x);
def del(f): delpaths([path(f)]);
def _assign(paths; value): value as $v | reduce path(paths) as $p (.; setpath($p; $v));
def _modify(paths; update): reduce path(paths) as $p (.; setpath($p; getpath($p) | update));
def recurse(f): def r: ., (f | select(. != null) | r); r;
def recurse(f; cond): def r: ., (f | select(cond) | r); r;
def recurse: recurse(.[]?);
def recurse_down: recurse;
def to_entries: [keys_unsorted[] as $k | {key: $k, value: .[$k]}];
def from_entries: map({(.key // .Key): (.value // .Value)}) | add | .//={};
def with_entries(f): to_entries | map(f) | from_entries;
def reverse: [.[length - 1 - range(0;length)]];
def indices($i): if type == "array" and ($i|type) == "array" then .[$i] elif type == "array" then .[[$i]] else .[$i] end;
def index($i):   if type == "array" and ($i|type) == "array" then .[$i] elif type == "array" then .[[$i]] else .[$i] end | .[0];
def rindex($i):  if type == "array" and ($i|type) == "array" then .[$i] elif type == "array" then .[[$i]] else .[$i] end | .[-1:][0];
def paths: path(recurse(if (type|. == "array" or . == "object") then .[] else empty end))|select(length > 0);
def paths(node_filter): . as $dot|paths|select(. as $p|$dot|getpath($p)|node_filter);
def any: reduce .[] as $i (false; . or $i);
def all: reduce .[] as $i (true; . and $i);
def any(condition): reduce .[] as $i (false; . or ($i|condition));
def any(generator; condition):
         [false,
         foreach generator as $i
                 (false;
                  if . then break elif $i | condition then true else . end;
                  if . then . else empty end)] | any;
def all(condition): reduce .[] as $i (true; . and ($i|condition));
def all(generator; condition): 
         [true,
         foreach generator as $i
                 (true;
                  if .|not then break elif $i | condition then . else false end;
                  if .|not then . else empty end)]|all;
def arrays: select(type == "array");
def objects: select(type == "object");
def iterables: arrays, objects;
def booleans: select(type == "boolean");
def numbers: select(type == "number");
def strings: select(type == "string");
def nulls: select(type == "null");
def values: arrays, objects, booleans, numbers, strings;
def scalars: select(. == null or . == true or . == false or type == "number" or type == "string");
def leaf_paths: paths(scalars);
def join($x): reduce .[] as $i (""; . + (if . == "" then $i else $x + $i end));
def flatten: reduce .[] as $i ([]; if $i | type == "array" then . + ($i | flatten) else . + [$i] end);
def flatten($x): reduce .[] as $i ([]; if $i | type == "array" and $x > 0 then . + ($i | flatten($x-1)) else . + [$i] end);
def range($x): range(0;$x);
def match(re; mode): _match_impl(re; mode; false)|.[];
def match($val): ($val|type) as $vt | if $vt == "string" then match($val; null)
   elif $vt == "array" and ($val | length) > 1 then match($val[0]; $val[1])
   elif $vt == "array" and ($val | length) > 0 then match($val[0]; null)
   else error( $vt + " not a string or array") end;
def test(re; mode): _match_impl(re; mode; true);
def test($val): ($val|type) as $vt | if $vt == "string" then test($val; null)
   elif $vt == "array" and ($val | length) > 1 then test($val[0]; $val[1])
   elif $vt == "array" and ($val | length) > 0 then test($val[0]; null)
   else error( $vt + " not a string or array") end;
def capture(re; mods): match(re; mods) | reduce ( .captures | .[] | select(.name != null) | { (.name) : .string } ) as $pair ({}; . + $pair);
def capture($val): ($val|type) as $vt | if $vt == "string" then capture($val; null)
   elif $vt == "array" and ($val | length) > 1 then capture($val[0]; $val[1])
   elif $vt == "array" and ($val | length) > 0 then capture($val[0]; null)
   else error( $vt + " not a string or array") end;
def scan(re):
  match(re; "g")
  |  if (.captures|length > 0)
      then [ .captures | .[] | .string ]
      else .string
      end ;
#
# If input is an array, then emit a stream of successive subarrays of length n (or less),
# and similarly for strings.
def _nwise(a; $n): if a|length <= $n then a else a[0:$n] , _nwise(a[$n:]; $n) end;
def _nwise($n): _nwise(.; $n);
#
# splits/1 produces a stream; split/1 is retained for backward compatibility.
def splits($re; flags): . as $s
     //  # multiple occurrences of "g" are acceptable
  | [ match($re; "g" + flags) | (.offset, .offset + .length) ]
  | [0] + . +[$s|length]
  | _nwise(2)
  | $s[.[0]:.[1] ] ;
def splits($re): splits($re; null);
#
# split emits an array for backward compatibility
def split($re; flags): [ splits($re; flags) ];
#
# If s contains capture variables, then create a capture object and pipe it to s
def sub($re; s):
  . as $in
  | [match($re)]
  | if length == 0 then $in
    else .[0]
    | . as $r
       //  # create the "capture" object:
    | reduce ( $r | .captures | .[] | select(.name != null) | { (.name) : .string } ) as $pair
        ({}; . + $pair)
    | $in[0:$r.offset] + s + $in[$r.offset+$r.length:]
    end ;
#/
#/ repeated substitution of re (which may contain named captures)
def gsub($re; s; flags):
#/   # _stredit(edits;s) - s is the "to" string, which might contain capture variables,
#/   # so if an edit contains captures, then create the capture object and pipe it to s
   def _stredit(edits; s):
     if (edits|length) == 0 then .
     else . as $in
       | (edits|length -1) as $l
       | (edits[$l]) as $edit
#/       # create the "capture" object:
       | ($edit | reduce ( $edit | .captures | .[] | select(.name != null) | { (.name) : .string } ) as $pair
         ({}; . + $pair) )
       | if . == {} then $in | .[0:$edit.offset]+s+.[$edit.offset+$edit.length:] | _stredit(edits[0:$l]; s)
         else (if $l == 0 then "" else ($in | _stredit(edits[0:$l]; s)) end) + (. | s)
         end
     end ;
  [match($re; flags + "g")] as $edits | _stredit($edits; s) ;
def gsub($re; s): gsub($re; s; "");
#
# range/3, with a `by` expression argument
def range($init; $upto; $by): 
    def _range: 
        if ($by > 0 and . < $upto) or ($by < 0 and . > $upto) then ., ((.+$by)|_range) else . end; 
    if $by == 0 then $init else $init|_range end | select(($by > 0 and . < $upto) or ($by < 0 and . > $upto));
# generic iterator/generator
def while(cond; update): 
     def _while: 
         if cond then ., (update | _while) else empty end; 
     try _while catch if .=="break" then empty else . end;
def limit($n; exp): if $n < 0 then exp else foreach exp as $item ([$n, null]; if .[0] < 1 then break else [.[0] -1, $item] end; .[1]) end;
def first(g): foreach g as $item ([false, null]; if .[0]==true then break else [true, $item] end; .[1]);
def last(g): reduce g as $item (null; $item);
def nth($n; g): if $n < 0 then error("nth doesn't support negative indices") else last(limit($n + 1; g)) end;
def first: .[0];
def last: .[-1];
def nth($n): .[$n];
# transpose a possibly jagged matrix, quickly; 
# rows are padded with nulls so the result is always rectangular.
def transpose:
  if . == [] then []
  else . as $in
  | (map(length) | max) as $max
  | length as $length
  | reduce range(0; $max) as $j
      ([]; . + [reduce range(0;$length) as $i ([]; . + [ $in[$i][$j] ] )] )
  end;
